c-----------------------------------------------------------------------
c     file nimeq_btr.f
c     contains a module for tracing field-lines generated by the
c     nimeq program.
c-----------------------------------------------------------------------
c-----------------------------------------------------------------------
c     code organization.
c-----------------------------------------------------------------------
c     0.  nimeq_btr
c     1.  beq_tr.
c     2.  beq_df_eval
c-----------------------------------------------------------------------
c-----------------------------------------------------------------------
c     0. module declaration for nimeq_btr
c-----------------------------------------------------------------------
      MODULE nimeq_btr
      USE local
      USE input
      USE input_eq
      IMPLICIT NONE
c-CHG
c     Removed Module variables to avoid global data for parellelism
c     bdir and lscale are now locally defined and passed into beq_df
c     by means of user_data(See cvode documentation) 
      CONTAINS
c-----------------------------------------------------------------------
c     subprogram 1. beq_tr is a real function that traces the poloidal
c     projection of the symmetric equilibrium field to determine whether
c     the starting point is topologically connected to the wall.
c     beq_tr returns:
c
c       field-line length<=blen_check*lref (the specified integration
c       length), or -1 if there is an error in the integration. 
c
c     the input parameters (rini,zini) are the initial poloidal
c     coordinates of the trace, and lref is the reference macroscopic
c     length.  the (x,y) input is the logical coordinate-pair of the
c     initial position within block ibl.
c-----------------------------------------------------------------------
      FUNCTION beq_tr(rini,zini,lref,x,y,ibl,stiff,ode_pkg) RESULT(lbeq)
      USE fields
      USE seam_storage_mod
      USE pardata
      USE nimeq_all
      USE fcvode_mod                    ! Fortran interface to CVODE
      USE fsundials_nvector_mod         ! Fortran interface to generic N_Vector
      USE fnvector_serial_mod           ! Fortran interface to serial N_Vector
      USE fsundials_linearsolver_mod ! Fortran interface to generic SUNLinearSolver
      USE fsunmatrix_dense_mod       ! Fortran interface to dense SUNMatrix
      USE fsunlinsol_dense_mod       ! Fortran interface to dense SUNLinearSolver
      USE fsundials_matrix_mod       ! Fortran interface to generic SUNMatrix
      USE omp_lib
      USE, INTRINSIC :: iso_c_binding

      REAL(r8), INTENT(IN) :: rini,zini,lref,x,y
      INTEGER(i4), INTENT(IN) :: ibl
      LOGICAL, INTENT(IN) :: stiff
      INTEGER(i4), INTENT(IN) :: ode_pkg          ! Switch between CVODE
                                                  ! and DLSODE
      REAL(c_double) :: lstart
      REAL(c_double) :: lout(1)
      REAL(c_double) :: lend
      REAL(c_double) :: crtol, catol ! relative and absolute tolerance
      INTEGER(c_int) :: ierr         ! error flag from C functions
      TYPE(c_ptr) :: cvode_mem                    ! CVODE memory

      TYPE(N_Vector), POINTER :: sunvec_y         ! sundials vector
      TYPE(SUNMatrix),       pointer :: sunmat_A     ! sundials matrix
      TYPE(SUNLinearSolver), pointer :: sunlinsol_LS ! sundials linear solver

      REAL(r8) :: lbeq

      INTEGER(i8), PARAMETER :: neq=3,nbtr=300000
      REAL(r8), PARAMETER :: rtol0=1.e-7_r8,rtoll=1.e-4_r8,
     $                       step1=1.e-3_r8,stepmx=0.5_r8,
     $                       stepmn=1.e-9_r8,distrat=50._r8
      REAL(r8), SAVE :: rtol
      REAL(r8), DIMENSION(:), ALLOCATABLE, SAVE :: rwork,atol
      INTEGER(i4), DIMENSION(:), ALLOCATABLE, SAVE :: iwork
      INTEGER(i4), SAVE :: itol,itask,istate,iopt,lrw,liw,mf
      LOGICAL, SAVE :: first_call=.true.

      REAL(r8) :: pathlen,pathend,poldist,lscale,bdir
      REAL(r8) :: jac,bmag
      REAL(r8), TARGET, DIMENSION(5) :: udata
      REAL(c_double), TARGET :: slnv(neq)
      INTEGER(i4) :: ibtr,ibtmp,nrbtmp,nbtmp

!$OMP THREADPRIVATE(rtol,rwork,atol,iwork,first_call)
!$OMP THREADPRIVATE(itol,itask,istate,iopt,lrw,liw,mf)
      SELECT CASE (ode_pkg)

      CASE (0)
c-----------------------------------------------------------------------
c     set parameters for the lsode integrator.
c-----------------------------------------------------------------------
      IF (first_call) THEN
        itol=2          !  flag for vector absolute tolerance
        rtol=0._r8      !  lsode input; rel. tol option not used here
        itask=1         !  flags a normal computation
        iopt=1          !  flag use of optional inputs
        lrw=MAX(22+9*neq+neq**2,20+16*neq)   !  size of real work array
        liw=20+neq      !   size of integer work array
        ALLOCATE(atol(neq))
        ALLOCATE(rwork(lrw))
        ALLOCATE(iwork(liw))
        first_call=.false.
      ENDIF

      IF (stiff) THEN
        mf=22         !  flag to chose the integration method;
                      !  22 is the stiff BDF method, internal Jacobian
      ELSE
        mf=10         !  10 is the nonstiff Adams method
      ENDIF

      rwork=0._r8
      rwork(5)=step1*lref    !  initial step size.
      rwork(6)=stepmx*lref   !  maximum step size.
      rwork(7)=stepmn*lref   !  minimum step size.
      iwork=0
      iwork(6)=nbtr   !  optional input for max number of steps.
      istate=1        !  start a new integration.
c-----------------------------------------------------------------------
c     the first and second dependent variables are poloidal positions
c     with units of length.  the third is the length along the field-
c     line, where a lower tolerance is acceptable and required, given
c     the step-function imposed at the domain border.
c-----------------------------------------------------------------------
      atol=(/rtol0*lref,rtol0*lref,rtoll*lref/)
c-----------------------------------------------------------------------
c     swap pointers so that the field-line integration has access to
c     the entire domain.
c-----------------------------------------------------------------------
      IF (nprocs>1) THEN
        ibtr=loc2glob(ibl)
        rbtmp=>rb
        tbtmp=>tb
        seamtmp=>seam
        rb=>rball
        tb=>tball
        seam=>seamall
        nrbtmp=nrbl
        nbtmp=nbl
        nrbl=nrbl_total
        nbl=nbl_total
      ELSE
        ibtr=ibl
      ENDIF
c-----------------------------------------------------------------------
c     initialize the independent and dependent variables.  in the
c     solution vector, slnv, the first three entries are the dependent
c     variables, (R,Z,len).  the three auxiliary entries are
c     (logical-x,logical-y,block-index), as used in the coordinate
c     search when updating the physical coordinates.
c-----------------------------------------------------------------------
      pathlen=0._r8
      pathend=blen_check*lref
c      slnv=(/rini,zini,0._r8,x,y,REAL(ibtr,r8)/)
      bdir=1._r8
      lscale=lref
c-----------------------------------------------------------------------
c     call the lsode integrator.
c-----------------------------------------------------------------------
c      CALL dlsode(beq_df_eval,neq,slnv,pathlen,pathend,
c     $            itol,rtol,atol,itask,istate,iopt,rwork,lrw,
c     $            iwork,liw,jac,mf )

      IF (istate==-1) THEN  !  lsode reports too much work
        poldist=SQRT((slnv(1)-rini)**2+(slnv(2)-zini)**2)
        IF (pathlen>distrat*poldist) THEN ! trace is circling: closed
          lbeq=blen_check*lref
        ELSE
          WRITE(*,*) "parallel trace"
          WRITE(*,*) "start: ib x y r z",ibtr,x,y,REAL((/rini,zini/))
          CALL nim_stop("Lsode is conducting excessive work.")
        ENDIF
      ELSE IF (istate/=2) THEN
        WRITE(*,*) "parallel trace"
        WRITE(*,*) "R Z",REAL(slnv(1:2),r4)
        WRITE(*,*) "start: ib x y",ibtr,x,y
        WRITE(*,*) "stuck: ib x y",NINT(slnv(6)),REAL(slnv(4:5),r4)
        CALL beq_df_eval(neq,0._r8,slnv,rwork)
        WRITE(*,*) "dfvec ",rwork(1:neq)
        CALL nim_stop("Lsode not converging on B-trace.")
      ELSE
        lbeq=slnv(3)
      ENDIF
c-----------------------------------------------------------------------
c     also trace the direction antiparallel to B, and return the shorter
c     of the two lengths.
c-----------------------------------------------------------------------
      rwork=0._r8
      rwork(5)=step1*lref    !  initial step size.
      rwork(6)=stepmx*lref   !  maximum step size.
      rwork(7)=stepmn*lref   !  minimum step size.
      iwork=0
      iwork(6)=nbtr   !  optional input for max number of steps.

      pathlen=0._r8
      pathend=blen_check*lref
c      slnv=(/rini,zini,0._r8,x,y,REAL(ibtr,r8)/)
      bdir=-1._r8
      istate=1
c      CALL dlsode(beq_df_eval,neq,slnv,pathlen,pathend,
c     $            itol,rtol,atol,itask,istate,iopt,rwork,lrw,
c     $            iwork,liw,jac,mf )
      IF (istate==-1) THEN  !  lsode reports too much work
        poldist=SQRT((slnv(1)-rini)**2+(slnv(2)-zini)**2)
        IF (pathlen>distrat*poldist) THEN ! trace is circling: closed
          lbeq=MIN(lbeq,blen_check*lref)
        ELSE
          WRITE(*,*) "anti-parallel trace"
          WRITE(*,*) "start: ib x y r z",ibtr,x,y,REAL((/rini,zini/))
          CALL nim_stop("Lsode is conducting excessive work.")
        ENDIF
      ELSE IF (istate/=2) THEN
        WRITE(*,*) "anti-parallel trace"
        WRITE(*,*) "R Z",REAL(slnv(1:2),r4)
        WRITE(*,*) "start: ib x y",ibtr,x,y
        WRITE(*,*) "stuck: ib x y",NINT(slnv(6)),REAL(slnv(4:5),r4)
        CALL beq_df_eval(neq,0._r8,slnv,rwork)
        WRITE(*,*) "dfvec ",rwork(1:neq)
        CALL nim_stop("Lsode not converging on B-trace.")
      ELSE
        lbeq=MIN(lbeq,slnv(3))
      ENDIF
c-----------------------------------------------------------------------
c     reset pointers.
c-----------------------------------------------------------------------
      IF (nprocs>1) THEN
        rb=>rbtmp
        tb=>tbtmp
        seam=>seamtmp
        nrbl=nrbtmp
        nbl=nbtmp
      ENDIF
c-----------------------------------------------------------------------
c     Use CVODE
c-----------------------------------------------------------------------
      CASE(1)
       lstart = 0.0_r8
       lend = blen_check*lref
       slnv=(/rini,zini,0.0_r8/) 
       bdir=1._r8
       lscale=lref
       udata = (/bdir,lscale,x,y,REAL(ibl,r8)/) 
       WRITE(*,*) slnv(1),slnv(2),slnv(3)
c-----------------------------------------------------------------------
c      Initialize N_vector, solver init
c-----------------------------------------------------------------------
       sunvec_y => FN_VMake_Serial(neq, slnv)
       IF (.not. associated(sunvec_y)) THEN
        CALL nim_stop('Error allocating sunvec_y')
       END IF
       
       IF (stiff) THEN
         cvode_mem = FCVodeCreate(CV_BDF)
       ELSE
         cvode_mem = FCVodeCreate(CV_ADAMS)
       END IF
       sunmat_A => FSUNDenseMatrix(neq,neq)
       sunlinsol_LS => FSUNDenseLinearSolver(sunvec_y, sunmat_A)

       IF (.not. c_associated(cvode_mem)) THEN
        CALL nim_stop('Error allocating cvode_mem')
       END IF

       ierr = FCVodeInit(cvode_mem, c_funloc(beq_df_cvode), lstart, 
     $                                                         sunvec_y)
       IF (ierr /= 0) THEN
        CALL nim_stop('Error in FCVodeInit, ierr = ')
       END if

       ierr = FCVodeSetUserData(cvode_mem, C_LOC(udata))
c-----------------------------------------------------------------------
c      Set Tolerances, min, max and init step size
c-----------------------------------------------------------------------
       crtol = rtol0
       catol = MIN(rtol0*lref,rtoll*lref)

       ierr = FCVodeSStolerances(cvode_mem, crtol, catol)
       IF (ierr /= 0) THEN
        CALL nim_stop('Error in FCVodeSStolerances, ierr = ')
       END IF
       
       ierr = FCVodeSetMaxNumSteps(cvode_mem,nbtr) 
       IF (ierr /= 0) THEN
        CALL nim_stop('Error in FCVodeSetMaxNumSteps,ierr = ')
       END IF
       ierr = FCVodeSetMinStep(cvode_mem,stepmn*lref)
       IF (ierr /= 0) THEN
        CALL nim_stop('Error in FCVodeSetMinStep, ierr = ')
       END IF
       ierr = FCVodeSetMaxStep(cvode_mem,stepmx*lref)
       IF (ierr /= 0) THEN
        CALL nim_stop('Error in FCVodeSetMaxStep, ierr = ')
       END IF
       ierr = FCVodeSetInitStep(cvode_mem,step1*lref)
       IF (ierr /= 0) THEN
        CALL nim_stop('Error in FCVodeSetInitStep, ierr = ')
       END IF
c-----------------------------------------------------------------------
c      Attach Linear solver object
c-----------------------------------------------------------------------
       ierr = FCVodeSetLinearSolver(cvode_mem, sunlinsol_LS, sunmat_A);
       if (ierr /= 0) then
        CALL nim_stop('Error in FCVodeSetLinearSolver')
       end if
c-----------------------------------------------------------------------
c      Solve ODE 
c-----------------------------------------------------------------------
       
       ierr = fcvode(cvode_mem, lend, sunvec_y, lout, CV_NORMAL)

       IF (ierr==-1) THEN  !  cvode reports too much work
         poldist=SQRT((slnv(1)-rini)**2+(slnv(2)-zini)**2)
         IF (lend>distrat*poldist) THEN ! trace is circling: closed
           lbeq=MIN(lbeq,blen_check*lref)
         ELSE
           WRITE(*,*) "parallel trace"
           WRITE(*,*) "start: ib x y r z",ibtr,x,y,REAL((/rini,zini/))
           WRITE(*,*) "Length, ",lout
           CALL nim_stop("cvode is conducting excessive work.")
         ENDIF
       ELSE IF (istate==2) THEN
         WRITE(*,*) "parallel trace"
         WRITE(*,*) "R Z",REAL(slnv(1:2),r4)
         WRITE(*,*) "start: ib x y",ibtr,x,y
c         WRITE(*,*) "stuck: ib x y",NINT(slnv(6)),REAL(slnv(4:5),r4)
         CALL nim_stop("cvode not converging on B-trace.")
       ELSE
        lbeq=slnv(3)
       ENDIF
c-----------------------------------------------------------------------
c     also trace the direction antiparallel to B, and return the shorter
c     of the two lengths.
c-----------------------------------------------------------------------
       CALL FN_VDestroy(sunvec_y)
       NULLIFY(sunvec_y)
       slnv=(/rini,zini,0._r8/)
       udata(1) = -1.0_r8
c-----------------------------------------------------------------------
c      Reinitialize N_vector, solver init
c-----------------------------------------------------------------------
       sunvec_y => FN_VMake_Serial(neq,slnv)
       IF (.not. associated(sunvec_y)) THEN
        CALL nim_stop('Error allocating sunvec_y')
       ENDIF
       
       ierr = FCVodeReInit(cvode_mem, lstart, sunvec_y)
       IF(ierr/=0) THEN
          CALL nim_stop("FCVodeReInit error in anti-parallel call")
       ENDIF
c-----------------------------------------------------------------------
c      Solve
c----------------------------------------------------------------------- 

       ierr = FCVode(cvode_mem, lend, sunvec_y, lout, CV_NORMAL)
       
       IF (ierr==-1) THEN  !  lsode reports too much work
         poldist=SQRT((slnv(1)-rini)**2+(slnv(2)-zini)**2)
         IF (pathlen>distrat*poldist) THEN ! trace is circling: closed
           lbeq=MIN(lbeq,blen_check*lref)
         ELSE
           WRITE(*,*) "anti-parallel trace"
           WRITE(*,*) "start: ib x y r z",ibtr,x,y,REAL((/rini,zini/))
           CALL nim_stop("Lsode is conducting excessive work.")
         ENDIF
       ELSE IF (ierr==2) THEN
         WRITE(*,*) "anti-parallel trace"
         WRITE(*,*) "R Z",REAL(slnv(1:2),r4)
         WRITE(*,*) "start: ib x y",ibtr,x,y
c         WRITE(*,*) "stuck: ib x y",NINT(slnv(6)),REAL(slnv(4:5),r4)
         CALL nim_stop("Lsode not converging on B-trace.")
       ELSE
         lbeq=MIN(lbeq,slnv(3))
       ENDIF
       
       CALL FCVodeFree(cvode_mem)
       ierr = FSUNLinSolFree(sunlinsol_LS)
       CALL FSUNMatDestroy(sunmat_A)
       CALL FN_VDestroy(sunvec_y)


      END SELECT
c-----------------------------------------------------------------------
c     terminate.
c-----------------------------------------------------------------------
      RETURN
      END FUNCTION beq_tr
c-----------------------------------------------------------------------
c     subprogram 2. beq_df_eval is a subroutine that evaluates the
c     derivative-function for tracing the poloidal projection of
c     toroidally symmetric magnetic field-lines.
c
c     this subroutine is in the format required for the lsode library.
c     the arguments are:
c       nsize (scalar integer input): system size
c       xind  (scalar real input): independent coordinate
c       rzvec (vector real input): current solution vector, (r,z)
c       dfvec (vector real output): derivative function (dr,dz)/dl
c
c     field-line trace uses the Hamiltonian aspects of the field-line
c     equations, du_j/dl = B^j/B, where the contravariant components
c     of B are B^j = B.grad(u_j) for B=grad(phi).[ IXgrad(psi)+F*I ]
c       B^1 = B_R = -(1/R)*d(psi)/dZ
c       B^2 = B_Z =  (1/R)*d(psi)/dR
c       B^3 = B_phi/R = F/R**2  (not used)
c
c     the third dependent variable is length, and dlength/dl=1.
c-----------------------------------------------------------------------
      SUBROUTINE beq_df_eval(nsize,xind,rzvec,dfvec)
      USE global
      USE fields
      USE seam_storage_mod
      USE dumpc
      USE cell_type_mod
      USE input
      USE nim_locate
      USE omp_lib

      INTEGER(i8), INTENT(IN) :: nsize
      REAL(r8), INTENT(IN) :: xind
      REAL(r8), DIMENSION(nsize+3), INTENT(INOUT) :: rzvec
      REAL(r8), DIMENSION(nsize), INTENT(OUT) :: dfvec

      TYPE(lagr_quad_2D_type) :: be_laq

      REAL(r8) :: rr,zz,xx,yy,dr,dz,bmag,lscale,bdir
      REAL(r8) :: jac,dxdr,dxdz,dydr,dydz
      REAL(r8), PARAMETER :: xy_buff=5.e-2_r8
      INTEGER(i4) :: ib,ibn,isearch,jsearch,ierr,iv,ivn,iblast
      INTEGER(i4), PARAMETER :: maxsearch=100
      TYPE(location_type):: p0
      TYPE(cell_type), POINTER :: item_pre
      LOGICAL :: failure
c-----------------------------------------------------------------------
c     the coordinate search uses routines from the dumpc module in
c     dump_reset, and the Newton root find mimics the get_bfield
c     routine from nimfl.
c
c     first update the logical coordinates, starting from the saved
c     auxiliary variables in rzvec.
c-----------------------------------------------------------------------
      rr=rzvec(1)
      zz=rzvec(2)
      xx=rzvec(4)
      yy=rzvec(5)
      ib=NINT(rzvec(6))
c-----------------------------------------------------------------------
c     adjust for periodic meshing if needed.
c-----------------------------------------------------------------------
      IF (gridshape == 'rect') THEN
        SELECT CASE(periodicity)
        CASE("y-dir")
          IF (zz > ymax) zz=ymin+MOD(zz-ymin,ymax-ymin)
          IF (zz < ymin) zz=ymax+MOD(zz-ymin,ymax-ymin)
        CASE("both")
          IF (zz > ymax) zz=ymin+MOD(zz-ymin,ymax-ymin)
          IF (zz < ymin) zz=ymax+MOD(zz-ymin,ymax-ymin)
          IF (rr > xmax) rr=xmin+MOD(rr-xmin,xmax-xmin)
          IF (rr < xmin) rr=xmax+MOD(rr-xmin,xmax-xmin)
        END SELECT
      ENDIF
c-----------------------------------------------------------------------
c     determine the new block index and logical coordinates within that
c     block.
c
c     use the nim_locate routines nim_br_locate and nim_br_contrz for
c     rblocks.  otherwise, use the old search routines.
c-----------------------------------------------------------------------
      IF (ib<=0) THEN
        dfvec=0._r8
        rzvec(6)=0._r8
        RETURN 
      ELSE IF (ib<=nrbl) THEN
c-TMP
c       WRITE(72,*) "find ",ib,REAL((/rr,zz,xx,yy/),r4)
        CALL nim_rb_locate(rr,zz,lscale,rb(ib),xx,yy,ierr)
        iblast=ib
      
        IF (ierr/=0.OR.xx>rb(ib)%mx+xy_buff.OR.yy>rb(ib)%my+xy_buff
     $      .OR.xx<-xy_buff.OR.yy<-xy_buff) THEN
c-TMP
c         WRITE(72,*) "lsng ",ib,ierr,REAL((/rr,zz,xx,yy/),r4)
          DO isearch=1,MIN(maxsearch,nbl)
            CALL nim_rb_contrz(rr,zz,rb(ib),seam(ib),ibn,ivn)
c-TMP
c           WRITE(72,*) "srch ",ib,ibn,ivn

            IF (ibn==ib) EXIT
            ib=ibn
            iv=ivn
            IF (ibn==0) EXIT
          ENDDO
          IF (ib>0.AND.ib<=nrbl) THEN
            IF (ib==iblast) THEN
              xx=-1.
              yy=-1.
            ELSE
              xx=seam(ib)%segment(iv)%intxys(1)
              yy=seam(ib)%segment(iv)%intxys(2)
            ENDIF
            CALL nim_rb_locate(rr,zz,lscale,rb(ib),xx,yy,ierr)
            IF (ierr/=0.OR.xx>rb(ib)%mx+xy_buff.OR.yy>rb(ib)%my+xy_buff
     $          .OR.xx<-xy_buff.OR.yy<-xy_buff) THEN
              WRITE(nim_wr,'(a,2es12.4,/,a,i5,a,2es12.4,/,a,i5,/,a,i5)')
     $          "  Lost trace at (r,z)=",rr,zz,
     $          "  From block ",ib," and (x,y)=",xx,yy,
     $          "  With error code ",ierr,"  Thread: ",
     $          OMP_GET_THREAD_NUM()
              CALL nim_stop("Beq_df_eval: refined point is lost.")
            ENDIF
          ENDIF

        ENDIF

        IF (ib>nrbl) THEN
          isearch = MAX(1_i4,NINT(xx))
          jsearch = MAX(1_i4,NINT(yy))
          lucky=>bl2cl(ib)%p(isearch,jsearch)%p
          p0%point(1:2)=(/rr,zz/)
          CALL rz_to_cell(p0,lucky,item_pre,failure,.FALSE.)
          CALL refine_cell(p0,lucky,failure,xx,yy,.FALSE.)
          ib=lucky%ib
        ENDIF
      ENDIF

      rzvec(4)=xx
      rzvec(5)=yy
      rzvec(6)=ib
c-----------------------------------------------------------------------
c     now find dR/dl, dZ/dl, and dl_interior/dl from the contravariant
c     components of B.  the be_n0 structure is a 4-vector to provide
c     all necessary information with one lagr_quad_eval call:
c     lambda=psi/R**2, and R (or 1 in linear geometry), R (both geoms),
c     and Z.
c-----------------------------------------------------------------------

      IF (ib<=0) THEN  ! field-line has hit the border: stop integrating
        dfvec=0._r8
        RETURN 
      ELSE IF (ib<=nrbl) THEN
c-CHG
c This is to avoid changing be_n0 from different threads
        CALL lagr_quad_2D_alloc(be_laq,rb(ib)%be_n0%mx,rb(ib)%be_n0%my,
     $                          rb(ib)%be_n0%nqty,rb(ib)%be_n0%n_side+1)
        be_laq = rb(ib)%be_n0

        CALL lagr_quad_eval(be_laq,xx,yy,1_i4)
        jac=be_laq%fx(3)*be_laq%fy(4)-
     $      be_laq%fx(4)*be_laq%fy(3)
        dxdr= be_laq%fy(4)/jac
        dxdz=-be_laq%fy(3)/jac
        dydr=-be_laq%fx(4)/jac
        dydz= be_laq%fx(3)/jac
        dfvec(1)=-(be_laq%fx(1)*dxdz+be_laq%fy(1)*dydz)*
     $            be_laq%f(2)
        IF (geom=='tor') THEN
          dfvec(2)=(be_laq%fx(1)*dxdr+be_laq%fy(1)*dydr)*
     $             be_laq%f(2)+2._r8*be_laq%f(1)
        ELSE
          dfvec(2)=be_laq%fx(1)*dxdr+be_laq%fy(1)*dydr
        ENDIF
        bmag=SQRT(dfvec(1)**2+dfvec(2)**2)
c-TMP
c       WRITE(72,*) "xy   ",REAL((/xx,yy/),r4)
c       WRITE(72,*) "drz  ",REAL((/dxdr,dxdz,dydr,dydz/),r4)
c       WRITE(72,*) "dp p ",REAL((/be_laq%fx(1),
c    $                             be_laq%fy(1),
c    $                             be_laq%f(1)/),r4)
c       WRITE(72,*) "Bp J ",REAL((/dfvec(1:2),jac/),r4)
      ELSE
        CALL tri_linear_eval(tb(ib)%be_n0,tb(ib)%tgeom,rr,zz,
     $                       lucky%icell,1_i4)
        dfvec(1)=-tb(ib)%be_n0%fy(1)*tb(ib)%be_n0%f(2)
        IF (geom=='tor') THEN
          dfvec(2)=tb(ib)%be_n0%fx(1)*tb(ib)%be_n0%f(2)+
     $             2._r8*tb(ib)%be_n0%f(1)
        ELSE
          dfvec(2)=tb(ib)%be_n0%fx(1)
        ENDIF
        bmag=SQRT(dfvec(1)**2+dfvec(2)**2)
      ENDIF
      dfvec(1:2)=bdir*dfvec(1:2)/(bmag+smallnum)
      dfvec(3)=1._r8
c-TMP
c     WRITE(72,*) "dfv  ",REAL(dfvec(1:3),r4)
c-----------------------------------------------------------------------
c     terminate.
c-----------------------------------------------------------------------
      RETURN
      END SUBROUTINE beq_df_eval
c-----------------------------------------------------------------------
c     subprogram 3. beq_df_cvode is a function that evaluates the
c     derivative-function for tracing the poloidal projection of
c     toroidally symmetric magnetic field-lines.
c
c     this subroutine is in the format required for the cvode library.
c     the arguments are:
c       tn    (scalar double input): current time
c       vec_y (N_Vector input)     : current solution N_vector, (r,z)
c       vec_f (N_vector output)    : derivative function (dr,dz)/dl
c       user_data   (c pointer)    : user-defined data
c
c     field-line trace uses the Hamiltonian aspects of the field-line
c     equations, du_j/dl = B^j/B, where the contravariant components
c     of B are B^j = B.grad(u_j) for B=grad(phi).[ IXgrad(psi)+F*I ]
c       B^1 = B_R = -(1/R)*d(psi)/dZ
c       B^2 = B_Z =  (1/R)*d(psi)/dR
c       B^3 = B_phi/R = F/R**2  (not used)
c
c     the third dependent variable is length, and dlength/dl=1.
c-----------------------------------------------------------------------
      INTEGER(c_int) function beq_df_cvode(tn,vec_y,vec_f,user_data)
     $ result(ierr) bind(C,name='beq_df_cvode') 
      USE global
      USE fields
      USE seam_storage_mod
      USE dumpc
      USE cell_type_mod
      USE input
      USE nim_locate
      USE omp_lib
      USE fsundials_nvector_mod
      USE, INTRINSIC :: iso_c_binding

      TYPE(N_Vector) :: vec_y
      TYPE(N_Vector) :: vec_f
      REAL(c_double), value :: tn
      TYPE(c_ptr), value :: user_data
      
      REAL(c_double), POINTER :: rzvec(:)
      REAL(c_double), POINTER :: dfvec(:)

      TYPE(lagr_quad_2D_type) :: be_laq

      REAL(r8) :: rr,zz,xx,yy,dr,dz,bmag,lscale,bdir
      REAL(r8), POINTER :: udata(:) 
      REAL(r8) :: jac,dxdr,dxdz,dydr,dydz
      REAL(r8), PARAMETER :: xy_buff=5.e-2_r8
      INTEGER(i4) :: ib,ibn,isearch,jsearch,iv,ivn,iblast
      INTEGER(i4), PARAMETER :: maxsearch=100
      TYPE(location_type):: p0
      TYPE(cell_type), POINTER :: item_pre
      LOGICAL :: failure
c-----------------------------------------------------------------------
c     Get data arrays from SUNDIALS vectors
c-----------------------------------------------------------------------
c DBG 
      rzvec => FN_VGetArrayPointer(vec_y)
      WRITE(*,*) 'Size rzvec :', SIZE(rzvec)
      dfvec => FN_VGetArrayPointer(vec_f)
c-----------------------------------------------------------------------
c     the coordinate search uses routines from the dumpc module in
c     dump_reset, and the Newton root find mimics the get_bfield
c     routine from nimfl.
c
c     first update the logical coordinates, starting from the saved
c     auxiliary variables in rzvec.
c-----------------------------------------------------------------------
      rr=rzvec(1)
      zz=rzvec(2)
      CALL C_F_POINTER(user_data,udata,[5])
      bdir = udata(1)
      lscale=udata(2)
      xx=udata(3)
      yy=udata(4)
      ib=NINT(udata(5))
c-DBG
      WRITE(*,*) bdir,lscale,xx,yy,ib
c-----------------------------------------------------------------------
c     adjust for periodic meshing if needed.
c-----------------------------------------------------------------------
      IF (gridshape == 'rect') THEN
        SELECT CASE(periodicity)
        CASE("y-dir")
          IF (zz > ymax) zz=ymin+MOD(zz-ymin,ymax-ymin)
          IF (zz < ymin) zz=ymax+MOD(zz-ymin,ymax-ymin)
        CASE("both")
          IF (zz > ymax) zz=ymin+MOD(zz-ymin,ymax-ymin)
          IF (zz < ymin) zz=ymax+MOD(zz-ymin,ymax-ymin)
          IF (rr > xmax) rr=xmin+MOD(rr-xmin,xmax-xmin)
          IF (rr < xmin) rr=xmax+MOD(rr-xmin,xmax-xmin)
        END SELECT
      ENDIF
c-----------------------------------------------------------------------
c     determine the new block index and logical coordinates within that
c     block.
c
c     use the nim_locate routines nim_br_locate and nim_br_contrz for
c     rblocks.  otherwise, use the old search routines.
c-----------------------------------------------------------------------
      IF (ib<=0) THEN
        dfvec=0._r8
        rzvec(6)=0._r8
        RETURN 
      ELSE IF (ib<=nrbl) THEN
c-TMP
c       WRITE(72,*) "find ",ib,REAL((/rr,zz,xx,yy/),r4)
        CALL nim_rb_locate(rr,zz,lscale,rb(ib),xx,yy,ierr)
        iblast=ib
      
        IF (ierr/=0.OR.xx>rb(ib)%mx+xy_buff.OR.yy>rb(ib)%my+xy_buff
     $      .OR.xx<-xy_buff.OR.yy<-xy_buff) THEN
c-TMP
c         WRITE(72,*) "lsng ",ib,ierr,REAL((/rr,zz,xx,yy/),r4)
          DO isearch=1,MIN(maxsearch,nbl)
            CALL nim_rb_contrz(rr,zz,rb(ib),seam(ib),ibn,ivn)
c-TMP
c           WRITE(72,*) "srch ",ib,ibn,ivn

            IF (ibn==ib) EXIT
            ib=ibn
            iv=ivn
            IF (ibn==0) EXIT
          ENDDO
          IF (ib>0.AND.ib<=nrbl) THEN
            IF (ib==iblast) THEN
              xx=-1.
              yy=-1.
            ELSE
              xx=seam(ib)%segment(iv)%intxys(1)
              yy=seam(ib)%segment(iv)%intxys(2)
            ENDIF
            CALL nim_rb_locate(rr,zz,lscale,rb(ib),xx,yy,ierr)
            IF (ierr/=0.OR.xx>rb(ib)%mx+xy_buff.OR.yy>rb(ib)%my+xy_buff
     $          .OR.xx<-xy_buff.OR.yy<-xy_buff) THEN
              WRITE(nim_wr,'(a,2es12.4,/,a,i5,a,2es12.4,/,a,i5,/,a,i5)')
     $          "  Lost trace at (r,z)=",rr,zz,
     $          "  From block ",ib," and (x,y)=",xx,yy,
     $          "  With error code ",ierr,"  Thread: ",
     $          OMP_GET_THREAD_NUM()
              CALL nim_stop("Beq_df_eval: refined point is lost.")
            ENDIF
          ENDIF

        ENDIF

        IF (ib>nrbl) THEN
          isearch = MAX(1_i4,NINT(xx))
          jsearch = MAX(1_i4,NINT(yy))
          lucky=>bl2cl(ib)%p(isearch,jsearch)%p
          p0%point(1:2)=(/rr,zz/)
          CALL rz_to_cell(p0,lucky,item_pre,failure,.FALSE.)
          CALL refine_cell(p0,lucky,failure,xx,yy,.FALSE.)
          ib=lucky%ib
        ENDIF
      ENDIF

      rzvec(4)=xx
      rzvec(5)=yy
      rzvec(6)=ib
c-----------------------------------------------------------------------
c     now find dR/dl, dZ/dl, and dl_interior/dl from the contravariant
c     components of B.  the be_n0 structure is a 4-vector to provide
c     all necessary information with one lagr_quad_eval call:
c     lambda=psi/R**2, and R (or 1 in linear geometry), R (both geoms),
c     and Z.
c-----------------------------------------------------------------------

      IF (ib<=0) THEN  ! field-line has hit the border: stop integrating
        dfvec=0._r8
        RETURN 
      ELSE IF (ib<=nrbl) THEN
c-CHG
c This is to avoid changing be_n0 from different threads
        CALL lagr_quad_2D_alloc(be_laq,rb(ib)%be_n0%mx,rb(ib)%be_n0%my,
     $                          rb(ib)%be_n0%nqty,rb(ib)%be_n0%n_side+1)
        be_laq = rb(ib)%be_n0

        CALL lagr_quad_eval(be_laq,xx,yy,1_i4)
        jac=be_laq%fx(3)*be_laq%fy(4)-
     $      be_laq%fx(4)*be_laq%fy(3)
        dxdr= be_laq%fy(4)/jac
        dxdz=-be_laq%fy(3)/jac
        dydr=-be_laq%fx(4)/jac
        dydz= be_laq%fx(3)/jac
        dfvec(1)=-(be_laq%fx(1)*dxdz+be_laq%fy(1)*dydz)*
     $            be_laq%f(2)
        IF (geom=='tor') THEN
          dfvec(2)=(be_laq%fx(1)*dxdr+be_laq%fy(1)*dydr)*
     $             be_laq%f(2)+2._r8*be_laq%f(1)
        ELSE
          dfvec(2)=be_laq%fx(1)*dxdr+be_laq%fy(1)*dydr
        ENDIF
        bmag=SQRT(dfvec(1)**2+dfvec(2)**2)
c-TMP
c       WRITE(72,*) "xy   ",REAL((/xx,yy/),r4)
c       WRITE(72,*) "drz  ",REAL((/dxdr,dxdz,dydr,dydz/),r4)
c       WRITE(72,*) "dp p ",REAL((/be_laq%fx(1),
c    $                             be_laq%fy(1),
c    $                             be_laq%f(1)/),r4)
c       WRITE(72,*) "Bp J ",REAL((/dfvec(1:2),jac/),r4)
      ELSE
        CALL tri_linear_eval(tb(ib)%be_n0,tb(ib)%tgeom,rr,zz,
     $                       lucky%icell,1_i4)
        dfvec(1)=-tb(ib)%be_n0%fy(1)*tb(ib)%be_n0%f(2)
        IF (geom=='tor') THEN
          dfvec(2)=tb(ib)%be_n0%fx(1)*tb(ib)%be_n0%f(2)+
     $             2._r8*tb(ib)%be_n0%f(1)
        ELSE
          dfvec(2)=tb(ib)%be_n0%fx(1)
        ENDIF
        bmag=SQRT(dfvec(1)**2+dfvec(2)**2)
      ENDIF
      dfvec(1:2)=bdir*dfvec(1:2)/(bmag+smallnum)
      dfvec(3)=1._r8
c-TMP
c     WRITE(72,*) "dfv  ",REAL(dfvec(1:3),r4)
c-----------------------------------------------------------------------
c     terminate.
c-----------------------------------------------------------------------
      ierr = 0
      RETURN
      END FUNCTION beq_df_cvode
c-----------------------------------------------------------------------
c     close module.
c-----------------------------------------------------------------------
      END MODULE nimeq_btr
